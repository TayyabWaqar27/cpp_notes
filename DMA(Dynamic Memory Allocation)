üìå Dynamic Memory Allocation (DMA) in C++
üîπ Definition

Dynamic Memory Allocation (DMA) is the process of allocating memory at runtime (while the program is running), instead of compile time.

Normal arrays (e.g., int arr[10];) have fixed size decided at compile time.

DMA lets the program decide how much memory to use based on user input or program logic.

üîπ new and delete

new ‚Üí allocates memory from the heap (dynamic memory area).

delete ‚Üí releases the memory back to the system to prevent memory leaks.

Example:

int* arr = new int[size];   // allocate array on heap
...
delete[] arr;               // free memory

üîπ Stack vs Heap

Stack memory:

Automatic allocation.

Memory is released when the function ends.

Example: int arr[10];

Heap memory:

Manual allocation using new.

Stays allocated until we delete it.

Example: int* arr = new int[size];

üîπ Advantages of DMA

Memory can be allocated based on runtime needs.

Avoids waste (no need to reserve too much upfront).

Useful for large arrays/structures.

üîπ Common Mistakes

Forgetting delete ‚Üí memory leak (unused memory not released).

Using memory after delete ‚Üí dangling pointer (dangerous).

Mixing delete and delete[]:

delete ptr; ‚Üí for single variables.

delete[] ptr; ‚Üí for arrays.
Use of DMA

Dynamic Memory Allocation (DMA) means allocating memory at runtime (when the program is running), instead of compile-time. In C++, DMA is done using the operators new and delete.

Why do we use DMA?

Avoid memory wastage

In static arrays, we must fix the size before running the program.

If we declare string names[1000]; but use only 40, the rest is wasted.

With DMA, we allocate only what is needed.

Flexibility at runtime

Memory size can be decided during program execution based on user input.

Heap storage

DMA stores data in the heap memory, which is much larger than stack memory.

Useful for large arrays or objects.

Manual memory control

We can create and destroy memory as needed.

Prevents unnecessary memory usage.

Syntax
// Single variable
int *p = new int; 
*p = 10;
delete p;  

// Array
int *arr = new int[5];  
delete[] arr;

Example
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    cout << "Enter number of students: ";
    cin >> n;

    string *names = new string[n];  // allocate exact memory

    for (int i = 0; i < n; i++) {
        cout << "Enter name of student " << i + 1 << ": ";
        cin >> names[i];
    }

    cout << "\nList of students:\n";
    for (int i = 0; i < n; i++) {
        cout << names[i] << endl;
    }

    delete[] names;  // free memory
    return 0;
}
Why Not Just Use Arrays?

Fixed Size (at compile time)

Arrays in C++ must have their size known before running the program.

Example:

int arr[100]; // fixed size


If you need only 40 elements, 60 remain wasted. If you need 200, it won‚Äôt work.

Memory Wastage

Declaring a big array just in case leads to wasted stack memory.

Stack vs Heap

Normal arrays are stored in the stack, which is limited (usually a few MBs).

Large arrays can cause a stack overflow.

DMA uses the heap, which is much larger and better for handling big data.

Runtime Flexibility

Arrays require size at compile time (or before main starts, if using const).

DMA lets the user decide at runtime how much memory is needed.

Array Limitations

Arrays cannot be resized once created.

If you need a growing/shrinking collection, arrays won‚Äôt help.

DMA (or better, vector) can handle variable size.

Example of Problem with Arrays
int main() {
    int n;
    cin >> n;   // user input
    int arr[n]; // ‚ùå Error in standard C++, size must be constant
}


This works in some compilers (like GCC, as an extension), but not standard C++.
With DMA:

int *arr = new int[n];  // ‚úÖ Works, size given at runtime
delete[] arr;


‚úÖ Conclusion

We don‚Äôt always use arrays because they are static, fixed in size, and stored on stack.

DMA gives flexibility, scalability, and avoids wastage.

For modern C++, prefer vector over raw arrays and DMA for safety and ease.


‚úÖ Summary

DMA helps when size is unknown at compile time.

Saves memory by allocating only what is needed.

Data stored in heap, released using delete.

In modern C++, it‚Äôs recommended to use vector, string, smart pointers instead of raw new/delete.

‚úÖ In short:
DMA gives flexibility by allowing memory to be allocated during runtime, but it requires responsible cleanup using delete to avoid memory leaks.


